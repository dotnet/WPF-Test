// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

//  Provides classes to generate documents and selections on them.

[assembly: Test.Uis.Management.VersionInformation("$Author: Microsoft $ $Change: 3 $ $Source: //depot/winmain_oob/wap_rtm/windowstest/client/wcptests/uis/Common/Library/Models/SelectedDocumentGenerator.cs $")]

namespace Test.Uis.Data
{
    #region Namespaces.

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Threading;
    using System.Text;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Controls.Primitives;
    using System.Windows.Documents;
    using System.Windows.Input;
    using System.Windows.Threading;

    using Test.Uis.Loggers;
    using Test.Uis.Utils;
    using Test.Uis.Wrappers;

    #endregion Namespaces.

    /// <summary>
    /// Provides an iterator-like object to generate different documents and
    /// different selections over their content.
    /// </summary>
    public class SelectedDocumentGenerator
    {
        #region Constructors.

        /// <summary>
        /// Initializes a new SelectedDocumentGenerator instance.
        /// </summary>
        public SelectedDocumentGenerator(UIElementWrapper wrapper)
        {
            if (wrapper == null)
            {
                throw new ArgumentNullException("wrapper");
            }

            this._wrapper = wrapper;
        }

        #endregion Constructors.

        #region Public methods.

        /// <summary>
        /// Generates new content or a new selection over the existing
        /// content.
        /// </summary>
        /// <returns>
        /// true if a different document was generated or a different selection made,
        /// false if there are no more distinct documents or selections.
        /// </returns>
        public bool Next()
        {
            System.Diagnostics.Debug.Assert(_wrapper != null);

            if (_contentGenerator == null)
            {
                System.Diagnostics.Debug.Assert(_selectionGenerator == null);
                _contentGenerator = new DocumentContentGenerator(GetDocument(), _xamlContentPruner);
            }

            do
            {
                if (_selectionGenerator == null)
                {
                    if (!_contentGenerator.Next()) return false;
                    _selectionGenerator = new DocumentSelectionIterator(_wrapper);
                }
                else
                {
                    if (_selectionGenerator.Next())
                    {
                        return true;
                    }
                    else
                    {
                        _selectionGenerator = null;
                    }
                }
            } while (true);
        }

        #endregion Public methods.

        #region Public properties.

        /// <summary>
        /// Content pruner object to keep the number of documents
        /// generated bound.
        /// </summary>
        public DocumentContentPruner ContentPruner
        {
            get { return _xamlContentPruner; }
            set { _xamlContentPruner = value; }
        }

        /// <summary>
        /// Selection iterator used to select different portions of
        /// different documents.
        /// </summary>
        public DocumentSelectionIterator SelectionIterator
        {
            get { return _selectionGenerator; }
            set { _selectionGenerator = value; }
        }

        #endregion Public properties.

        #region Private methods.

        /// <summary>Gets the document from the element wrapper.</summary>
        private FlowDocument GetDocument()
        {
            if (_wrapper.Element is RichTextBox)
            {
                return ((RichTextBox)_wrapper.Element).Document;
            }
            else if (_wrapper.Element is FlowDocumentPageViewer)
            {
                return (FlowDocument)((FlowDocumentPageViewer)_wrapper.Element).Document;
            }
            throw new NotSupportedException("Element not supported: " + _wrapper.Element.GetType());
        }

        #endregion Private methods.

        #region Private fields.

        private DocumentContentPruner _xamlContentPruner;
        private DocumentContentGenerator _contentGenerator;
        private DocumentSelectionIterator _selectionGenerator;
        private UIElementWrapper _wrapper;

        #endregion Private fields.
    }

    /// <summary>
    /// Provides options to keep the number of documents generated by
    /// a DocumentContentGenerator limited.
    /// </summary>
    public class DocumentContentPruner
    {
        #region Constructors.

        /// <summary>
        /// Initializes a new DocumentContentPruner instance with default prune
        /// settings.
        /// </summary>
        public DocumentContentPruner() : this (null)
        {
        }

        /// <summary>
        /// Initializes a new DocumentContentPruner instance that will only
        /// allow the specified types to be generated.
        /// </summary>
        public DocumentContentPruner(List<Type> types)
        {
            this.Types = types;
            this._typeBreadth = new Dictionary<Type, List<int>>();
            this._typeDepth = new Dictionary<Type, int>();
        }

        #endregion Constructors.

        #region Public methods.

        /// <summary>
        /// Returns a list of children counts for an element of the specified
        /// type.
        /// </summary>
        /// <param name='type'>Type of element to get breadths for.</param>
        /// <returns>
        /// A list with the counts of elements to generate as children for
        /// the specified type.
        /// </returns>
        public List<int> GetBreadthForElementChildren(Type type)
        {
            List<int> breadth;

            if (type == null)
            {
                throw new ArgumentNullException("type");
            }

            if (_typeBreadth.TryGetValue(type, out breadth))
            {
                return breadth;
            }
            else
            {
                return new List<int>(new int[] { 1 });
            }
        }

        /// <summary>
        /// Gets the maximum depth at which an element of the specified
        /// type is allowed.
        /// </summary>
        /// <param name='type'>Type of element to get depth for.</param>
        /// <returns>
        /// The maximum depth at which an element of the specified
        /// type is allowed.
        /// </returns>
        public int GetDepthForElement(Type type)
        {
            int depth;

            if (type == null)
            {
                throw new ArgumentNullException("type");
            }

            if (_typeDepth.TryGetValue(type, out depth))
            {
                return depth;
            }
            else
            {
                // Some sample depths:
                // FlowDocument:1 -> Table:2 -> TableRowGroup:3 -> TableRow:4 -> TableCell:5
                // FlowDocument:1 -> List:2  -> ListItem:3
                if (typeof(Paragraph).IsAssignableFrom(type))
                {
                    return 16;
                }
                else if (typeof(Run).IsAssignableFrom(type))
                {
                    return 16;
                }
                else if (typeof(TableRowGroup).IsAssignableFrom(type))
                {
                    return 3;
                }
                else if (typeof(TableRow).IsAssignableFrom(type))
                {
                    return 4;
                }
                else if (typeof(TableCell).IsAssignableFrom(type))
                {
                    return 5;
                }
                else if (typeof(ListItem).IsAssignableFrom(type))
                {
                    return 3;
                }
                else
                {
                    return 2;
                }
            }
        }

        /// <summary>Checks whether the specified type should be generated.</summary>
        /// <param name='type'>Type to check.</param>
        /// <returns>
        /// true if the generator is allowed to use the given type; false
        /// otherwise.
        /// </returns>
        public bool IsTypeAllowed(Type type)
        {
            if (this._types.Count == 0)
            {
                return true;
            }
            else
            {
                return this._types.Contains(type);
            }
        }

        #endregion Public methods.

        #region Public properties.

        /// <summary>
        /// Indicates which types are allowed.
        /// </summary>
        public List<Type> Types
        {
            get { return _types; }
            set { _types = value ?? new List<Type>(); }
        }

        /// <summary>
        /// Indicates the maximum depth at which an element of a given type
        /// is allowed.
        /// </summary>
        public Dictionary<Type, int> TypeDepth
        {
            get { return _typeDepth; }
            set { _typeDepth = value ?? new Dictionary<Type, int>(); }
        }

        /// <summary>
        /// Indicates the breadths that will be generated for the children
        /// of elements of specific types.
        /// </summary>
        public Dictionary<Type, List<int>> TypeBreadth
        {
            get { return _typeBreadth; }
            set { _typeBreadth = value ?? new Dictionary<Type, List<int>>(); }
        }

        #endregion Public properties.

        #region Private fields.

        private List<Type> _types;
        private Dictionary<Type, int> _typeDepth;
        private Dictionary<Type, List<int>> _typeBreadth;

        #endregion Private fields.
    }

    /// <summary>
    /// Provides an iterator-like document generator.
    /// </summary>
    public class DocumentContentGenerator
    {
        #region Constructors.

        /// <summary>Initializes a new DocumentContentGenerator instance.</summary>
        /// <param name='document'>Document in which to generate content.</param>
        public DocumentContentGenerator(FlowDocument document): this(document, null)
        {
        }

        /// <summary>Initializes a new DocumentContentGenerator instance.</summary>
        /// <param name='document'>Document in which to generate content.</param>
        /// <param name='pruner'>Pruner object used to limit content generation.</param>
        public DocumentContentGenerator(FlowDocument document, DocumentContentPruner pruner)
        {
            if (document == null)
            {
                throw new ArgumentNullException("document");
            }

            this._document = document;
            this._pruner = pruner ?? new DocumentContentPruner();
            this._documentNode = new FlowDocumentNode(document, this);
        }

        #endregion Constructors.

        #region Public methods.

        /// <summary>Generates a different document.</summary>
        /// <returns>
        /// true if a different document was generated
        /// false if there are no more distinct documents.
        /// </returns>
        public bool Next()
        {
            System.Diagnostics.Debug.Assert(_document != null);
            System.Diagnostics.Debug.Assert(_documentNode != null);
            return _documentNode.Next();
        }

        #endregion Public methods.

        #region Public properties.

        /// <summary>Objects used to limit content generation.</summary>
        public DocumentContentPruner Pruner
        {
            get { return this._pruner; }
            set { this._pruner = value ?? new DocumentContentPruner(); }
        }

        #endregion Public properties.

        #region Private fields.

        private FlowDocument _document;
        private FlowDocumentNode _documentNode;
        private DocumentContentPruner _pruner;

        // Collections are filled in with [n] number of items.
        private static DependencyPropertySetterIterator s_emptyIterator = new DependencyPropertySetterIterator();
        private static System.Windows.Media.FontFamily[] s_fontFamilyValues = new System.Windows.Media.FontFamily[] {
            new System.Windows.Media.FontFamily("Arial"), new System.Windows.Media.FontFamily("Lucida Console"),
        };
        private static System.Windows.Media.Brush[] s_brushValues = new System.Windows.Media.Brush[] {
            BrushData.GradientBrush.Brush, System.Windows.Media.Brushes.DarkBlue
        };
        private static object[] s_thicknessValues = new object[] {
            new Thickness(0), new Thickness(1.5d),
        };
        private static object[] s_flowDirectionValues = new object[] {
            FlowDirection.LeftToRight, FlowDirection.RightToLeft,
        };

        #endregion Private fields.

        #region Dependency property helper classes.

        class DependencyPropertyValueIterator
        {
            public DependencyPropertyValueIterator(DependencyProperty property, object[] values)
            {
                this._property = property;
                this._values = values;
            }

            public bool Next()
            {
                if (_valueIndex == _values.Length) return false;
                _valueIndex++;
                return true;
            }

            public void Reset()
            {
                _valueIndex = 0;
            }

            public DependencyProperty Property { get { return _property; } }
            public object Value { get { return _values[_valueIndex - 1]; } }

            private DependencyProperty _property;
            private object[] _values;
            private int _valueIndex;
        }

        class DependencyPropertySetterIterator
        {
            public DependencyPropertySetterIterator()
            {
            }

            public DependencyObject Target
            {
                get { return this._target; }
                set { this._target = value; }
            }

            public DependencyPropertyValueIterator[] Iterators
            {
                get { return this._iterators; }
                set { this._iterators = value; }
            }

            public bool Next()
            {
                // NOTE: not actually exhaustive combinations, but rather a one-time pass.
                if (_iterators == null) return false;
                if (_iteratorIndex == _iterators.Length) return false;
                do
                {
                    DependencyPropertyValueIterator i = _iterators[_iteratorIndex];
                    if (i.Next())
                    {
                        Target.SetValue(i.Property, i.Value);
                        return true;
                    }
                    else
                    {
                        i.Reset();
                        _iteratorIndex++;
                    }
                } while (_iteratorIndex < _iterators.Length);
                return false;
            }

            public void Reset()
            {
                if (_iterators != null)
                {
                    for (int i = 0; i < _iterators.Length; i++)
                    {
                        _iterators[i].Reset();
                    }
                    _iteratorIndex = 0;
                }
            }

            private DependencyPropertyValueIterator[] _iterators;
            private int _iteratorIndex;
            private DependencyObject _target;
        }

        #endregion Dependency property helper classes.

        #region TextElementNode helper classes.

        abstract class TextElementNode
        {
            #region Public methods.

            public abstract bool Next();

            public virtual void Reset()
            {
                PropertyIterator.Reset();
            }

            #endregion Public methods.

            #region Public properties.

            public object Element
            {
                get { return this._element; }
                set { this._element = value; }
            }

            public Type ElementType
            {
                get { return (_element == null) ? this._elementType : _element.GetType(); }
                set { this._elementType = value; }
            }

            public int Depth
            {
                get { return this._depth; }
                set { this._depth = value; }
            }

            public DocumentContentGenerator Generator
            {
                get { return this._generator; }
                set { this._generator = value; }
            }

            public int MaxDepth
            {
                get
                {
                    return Generator.Pruner.GetDepthForElement(ElementType);
                }
            }

            public DependencyPropertySetterIterator PropertyIterator
            {
                get { return _propertyIterator; }
                set { this._propertyIterator = value; }
            }

            #endregion Public properties.

            #region Private fields.

            private int _depth;
            private object _element;
            private Type _elementType;
            private DependencyPropertySetterIterator _propertyIterator;
            private DocumentContentGenerator _generator;

            #endregion Private fields.

            public static TextElementNode CreateElementNode(Type type, TextElementNode parent)
            {
                TextElementNode result = null;

                if (type == null)
                {
                    throw new ArgumentNullException("type");
                }
                if (parent == null)
                {
                    throw new ArgumentNullException("parent");
                }

                if (type == typeof(Paragraph))
                {
                    result = new ParagraphNode();
                    /*
                    result.PropertyIterator = new DependencyPropertySetterIterator();
                    result.PropertyIterator.Iterators = new DependencyPropertyValueIterator[] {
                        new DependencyPropertyValueIterator(Paragraph.FlowDirectionProperty, FlowDirectionValues),
                        new DependencyPropertyValueIterator(Paragraph.BackgroundProperty, BrushValues),
                    };
                    */
                }
                else if (type == typeof(Section))
                {
                    result = new SectionNode();
                    /*
                    result.PropertyIterator = new DependencyPropertySetterIterator();
                    result.PropertyIterator.Iterators = new DependencyPropertyValueIterator[] {
                        new DependencyPropertyValueIterator(Paragraph.BorderThicknessProperty, ThicknessValues),
                    };
                    */
                }
                else if (type == typeof(List))
                {
                    result = new ListNode();
                }
                else if (type == typeof(ListItem))
                {
                    result = new ListItemNode();
                }
                else if (type == typeof(Table))
                {
                    result = new TableNode();
                }
                else if (type == typeof(TableRowGroup))
                {
                    result = new TableRowGroupNode();
                }
                else if (type == typeof(TableRow))
                {
                    result = new TableRowNode();
                }
                else if (type == typeof(TableCell))
                {
                    result = new TableCellNode();
                }
                else if (type == typeof(Run))
                {
                    result = new RunNode();
                    /*
                    result.PropertyIterator = new DependencyPropertySetterIterator();
                    result.PropertyIterator.Iterators = new DependencyPropertyValueIterator[] {
                        new DependencyPropertyValueIterator(Run.FontFamilyProperty, FontFamilyValues),
                        new DependencyPropertyValueIterator(Run.ForegroundProperty, BrushValues),
                    };
                    */
                }

                if (result == null)
                {
                    throw new NotSupportedException("TextElementNode not supported for " + type);
                }

                result.Depth = parent.Depth + 1;
                result.ElementType = type;
                result.Generator = parent.Generator;

                if (result.PropertyIterator == null)
                {
                    result.PropertyIterator = s_emptyIterator;
                }

                return result;
            }
        }

        abstract class BlockContainerNode : TextElementNode
        {
            public override bool Next()
            {
                if (PropertyIterator.Next()) return true;
                if (Depth > MaxDepth) return false;
                if (this._collection == null)
                {
                    Reset();
                }
                return this._collection.Next();
            }

            public override void Reset()
            {
                base.Reset();
                this._collection = new BlockCollectionNode(ElementBlockCollection, this);
            }

            protected abstract BlockCollection ElementBlockCollection { get; }

            private BlockCollectionNode _collection;
        }

        class FlowDocumentNode : TextElementNode
        {
            #region Constructors.

            public FlowDocumentNode(FlowDocument document, DocumentContentGenerator generator)
            {
                this.Element = document;
                this.ElementType = document.GetType();
                this.Depth = 1;
                this.Generator = generator;
                Reset();
            }

            #endregion Constructors.

            #region Public methods.

            public override bool Next()
            {
                return _collectionNode.Next();
            }

            public override void Reset()
            {
                this._collectionNode = new BlockCollectionNode(((FlowDocument)Element).Blocks, this);
            }

            #endregion Public methods.

            #region Private fields.

            private BlockCollectionNode _collectionNode;

            #endregion Private fields.
        }

        class ParagraphNode : TextElementNode
        {
            public override bool Next()
            {
                if (Depth > MaxDepth) return false;
                if (_collection == null)
                {
                    Reset();
                }
                return _collection.Next();
            }

            public override void Reset()
            {
                _collection = new InlineCollectionNode(Paragraph.Inlines, this);
            }

            public Paragraph Paragraph { get { return (Paragraph)Element; } }
            private InlineCollectionNode _collection;
        }

        class SectionNode : BlockContainerNode
        {
            protected override BlockCollection ElementBlockCollection
            {
                get { return ((Section)Element).Blocks; }
            }
        }

        class ListNode : TextElementNode
        {
            public override bool Next()
            {
                if (Depth > MaxDepth) return false;
                if (_collection == null)
                {
                    Reset();
                }
                return _collection.Next();
            }

            public override void Reset()
            {
                _collection = new ListItemCollectionNode(List.ListItems, this);
            }

            public List List { get { return (List)Element; } }
            private ListItemCollectionNode _collection;
        }

        class ListItemNode : BlockContainerNode
        {
            protected override BlockCollection ElementBlockCollection
            {
                get { return ((ListItem)Element).Blocks; }
            }
        }

        class RunNode : TextElementNode
        {
            public override bool Next()
            {
                if (_stringIndex < s_strings.Length)
                {
                    Run.Text = s_strings[_stringIndex];
                    _stringIndex++;
                    return true;
                }
                else
                {
                    if (PropertyIterator.Next()) return true;
                    return false;
                }
            }

            public override void Reset()
            {
                base.Reset();
                _stringIndex = 0;
            }

            private int _stringIndex;
            private static string[] s_strings = new string[] {
                "",
                TextScript.Arabic.Sample,
                TextScript.Katakana.Sample,
                TextScript.Latin.Sample,
            };
            public Run Run { get { return (Run)Element; } }
        }

        class TableNode : TextElementNode
        {
            public override bool Next()
            {
                if (Depth > MaxDepth) return false;
                if (_collection == null)
                {
                    Reset();
                }
                return _collection.Next();
            }

            public override void Reset()
            {
                base.Reset();
                _collection = new TableRowGroupCollectionNode(((Table)Element).RowGroups, this);
            }

            private TableRowGroupCollectionNode _collection;
        }

        class TableRowGroupNode : TextElementNode
        {
            public override bool Next()
            {
                if (Depth > MaxDepth) return false;
                if (_collection == null)
                {
                    Reset();
                }
                return _collection.Next();
            }

            public override void Reset()
            {
                base.Reset();
                _collection = new TableRowCollectionNode(((TableRowGroup)Element).Rows, this);
            }

            private TableRowCollectionNode _collection;
        }

        class TableRowNode : TextElementNode
        {
            public override bool Next()
            {
                if (Depth > MaxDepth) return false;
                if (_collection == null)
                {
                    Reset();
                }
                return _collection.Next();
            }

            public override void Reset()
            {
                base.Reset();
                _collection = new TableCellCollectionNode(((TableRow)Element).Cells, this);
            }

            private TableCellCollectionNode _collection;
        }

        class TableCellNode : BlockContainerNode
        {
            protected override BlockCollection ElementBlockCollection
            {
                get { return ((TableCell)Element).Blocks; }
            }
        }

        #endregion TextElementNode helper classes.

        #region ElementCollection helper classes.

        abstract class ElementCollection
        {
            protected ElementCollection(TextElementNode owner)
            {
                this._owner = owner;
                this._collectionCountIndex = 0;
            }

            public bool Next()
            {
                // Delay-initialize this as much as possible.
                if (this._breadths == null)
                {
                    this._breadths = _owner.Generator.Pruner.GetBreadthForElementChildren(_owner.ElementType);
                }

                if (_collectionCountIndex >= _breadths.Count)
                {
                    return false;
                }

                int childrenCount = _breadths[_collectionCountIndex];

                if (childrenCount == 0)
                {
                    // Special case: we want to try empty collections.
                    _collectionCountIndex++;
                    return true;
                }

                if (_engine == null)
                {
                    Dimension[] dimensions = new Dimension[childrenCount];
                    for (int i = 0; i < dimensions.Length; i++)
                    {
                        dimensions[i] = new Dimension("d-" + i, GetDimensionValues());
                    }
                    _engine = CombinatorialEngine.FromDimensions(dimensions);
                }

                if (_nodes == null)
                {
                    Hashtable h = new Hashtable();
                    while (true)
                    {
                        if (_engine.Next(h))
                        {
                            _nodes = new TextElementNode[childrenCount];
                            bool areAllAllowed = true;
                            for (int i = 0; i < childrenCount; i++)
                            {
                                Type elementType = (Type)h["d-" + i];
                                if (!Generator.Pruner.IsTypeAllowed(elementType))
                                {
                                    areAllAllowed = false;
                                    break;
                                }
                                TextElementNode node = TextElementNode.CreateElementNode(elementType, _owner);
                                node.Element = Activator.CreateInstance(elementType);
                                node.PropertyIterator.Target = (DependencyObject)node.Element;
                                _nodes[i] = node;
                            }
                            if (!areAllAllowed)
                            {
                                continue;
                            }

                            // Modify the tree only if there is something to
                            // replace the contents with.
                            ClearCollection();
                            foreach (TextElementNode node in _nodes)
                            {
                                AddToCollection(node.Element);
                            }
                            _nodeIndex = 0;
                            return true;
                        }
                        else
                        {
                            _engine = null;
                            _collectionCountIndex++;
                            return Next();
                        }
                    }
                }

                while (_nodeIndex < _nodes.Length)
                {
                    if (_nodes[_nodeIndex].Next())
                    {
                        return true;
                    }
                    else
                    {
                        _nodes[_nodeIndex].Reset();
                        _nodeIndex++;
                    }
                }

                _nodes = null;
                return Next();
            }

            protected abstract object[] GetDimensionValues();
            protected abstract void ClearCollection();
            protected abstract void AddToCollection(object o);

            private List<int> _breadths;
            private int _collectionCountIndex;
            private CombinatorialEngine _engine;
            private TextElementNode[] _nodes;
            private int _nodeIndex;
            private TextElementNode _owner;
            private DocumentContentGenerator Generator { get { return _owner.Generator; } }

            public int CollectionCountIndex { get { return this._collectionCountIndex; } }
        }

        class BlockCollectionNode: ElementCollection
        {
            public BlockCollectionNode(BlockCollection collection, TextElementNode owner): base (owner)
            {
                this._collection = collection;
            }

            protected override object[] GetDimensionValues()
            {
                return s_blockDimensionValues;
            }

            protected override void ClearCollection()
            {
                _collection.Clear();
            }

            protected override void AddToCollection(object o)
            {
                _collection.Add((Block)o);
            }

            private BlockCollection _collection;
            private static object[] s_blockDimensionValues = new object[] {
                typeof(Table), typeof(Paragraph), typeof(Section), typeof(List)
            };
        }

        class TableRowGroupCollectionNode : ElementCollection
        {
            public TableRowGroupCollectionNode(TableRowGroupCollection collection, TextElementNode owner)
                : base(owner)
            {
                this._collection = collection;
            }

            protected override object[] GetDimensionValues()
            {
                return s_tableRowGroupDimensionValues;
            }

            protected override void ClearCollection()
            {
                _collection.Clear();
            }

            protected override void AddToCollection(object o)
            {
                _collection.Add((TableRowGroup)o);
            }

            private TableRowGroupCollection _collection;
            private static object[] s_tableRowGroupDimensionValues = new object[] { typeof(TableRowGroup) };
        }

        class TableRowCollectionNode : ElementCollection
        {
            public TableRowCollectionNode(TableRowCollection collection, TextElementNode owner)
                : base(owner)
            {
                this._collection = collection;
            }

            protected override object[] GetDimensionValues()
            {
                return s_tableRowDimensionValues;
            }

            protected override void ClearCollection()
            {
                _collection.Clear();
            }

            protected override void AddToCollection(object o)
            {
                _collection.Add((TableRow)o);
            }

            private TableRowCollection _collection;
            private static object[] s_tableRowDimensionValues = new object[] { typeof(TableRow) };
        }

        class TableCellCollectionNode : ElementCollection
        {
            public TableCellCollectionNode(TableCellCollection collection, TextElementNode owner)
                : base(owner)
            {
                this._collection = collection;
            }

            protected override object[] GetDimensionValues()
            {
                return s_tableCellDimensionValues;
            }

            protected override void ClearCollection()
            {
                _collection.Clear();
            }

            protected override void AddToCollection(object o)
            {
                _collection.Add((TableCell)o);
            }

            private TableCellCollection _collection;
            private static object[] s_tableCellDimensionValues = new object[] { typeof(TableCell) };
        }

        class InlineCollectionNode : ElementCollection
        {
            public InlineCollectionNode(InlineCollection collection, TextElementNode owner)
                : base(owner)
            {
                this._collection = collection;
            }

            protected override object[] GetDimensionValues()
            {
                return s_inlineDimensionValues;
            }

            protected override void ClearCollection()
            {
                _collection.Clear();
            }

            protected override void AddToCollection(object o)
            {
                _collection.Add((Inline)o);
            }

            private InlineCollection _collection;
            private static object[] s_inlineDimensionValues = new object[] { typeof(Run) };
        }

        class ListItemCollectionNode : ElementCollection
        {
            public ListItemCollectionNode(ListItemCollection collection, TextElementNode owner)
                : base(owner)
            {
                this._collection = collection;
            }

            protected override object[] GetDimensionValues()
            {
                return s_listItemDimensionValues;
            }

            protected override void ClearCollection()
            {
                _collection.Clear();
            }

            protected override void AddToCollection(object o)
            {
                _collection.Add((ListItem)o);
            }

            private ListItemCollection _collection;
            private static object[] s_listItemDimensionValues = new object[] { typeof(ListItem) };
        }

        #endregion ElementCollection helper classes.
    }

    /// <summary>
    /// Provides an iterator-like interface over selections in a document.
    /// </summary>
    public class DocumentSelectionIterator
    {
        #region Constructors.

        /// <summary>Initializes a new DocumentSelectionIterator instance.</summary>
        public DocumentSelectionIterator(UIElementWrapper wrapper): this(wrapper, null)
        {
        }

        /// <summary>Initializes a new DocumentSelectionIterator instance.</summary>
        public DocumentSelectionIterator(UIElementWrapper wrapper, TextSelectionTestValue[] selectionValues)
        {
            if (wrapper == null)
            {
                throw new ArgumentNullException("wrapper");
            }
            if (selectionValues == null)
            {
                selectionValues = s_defaultSelectionValues;
            }

            this._wrapper = wrapper;
            this._selectionValues = selectionValues;
        }

        #endregion Constructors.

        #region Public methods.

        /// <summary>Selects a different portion of the content.</summary>
        /// <returns>
        /// true if a different portion of the content was selected,
        /// false if there are no more distinct selections.
        /// </returns>
        public bool Next()
        {
            System.Diagnostics.Debug.Assert(_wrapper != null);
            System.Diagnostics.Debug.Assert(_selectionValueIndex <= _selectionValues.Length);

            bool selected;
            do
            {
                if (_selectionValueIndex == _selectionValues.Length)
                {
                    return false;
                }
                selected = TextSelectionData.GetForValue(_selectionValues[_selectionValueIndex]).Select(_wrapper);
                _selectionValueIndex++;
            } while (!selected);

            return true;
        }

        /// <summary>Resets the enumeration.</summary>
        public void Reset()
        {
            _selectionValueIndex = 0;
        }

        #endregion Public methods.

        #region Private fields.

        private int _selectionValueIndex;
        private UIElementWrapper _wrapper;
        private TextSelectionTestValue[] _selectionValues;
        private static TextSelectionTestValue[] s_defaultSelectionValues = new TextSelectionTestValue[] {
            TextSelectionTestValue.EmptyDocumentStart,
            TextSelectionTestValue.SpanAllText,
        };

        #endregion Private fields.
    }
}
